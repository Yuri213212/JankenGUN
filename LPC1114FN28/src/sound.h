#define chbias				896
#define vol					5

/*
const uint32_t freqmul[12]={
	2247346,2380981,2522561,2672560,2831479,2999848,
	3178228,3367215,3567440,3779571,4004316,4242425,
};
*/
const uint32_t freqmul[12]={//B-5=1000Hz
	2275180,2410469,2553803,2705660,2866547,3037000,
	3217590,3408918,3611623,3826381,4053909,4294967,
};

const int8_t wavedata[]={
//rec parts
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
	0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
//rec parts
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

enum SOUND_ENUM{
	SND_LOSE=0,
	SND_DRAW,
	SND_WIN,
};

const uint8_t sound_pattern[]={
	//rec4	225bpm	lose
	0x25,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0x25,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,

	//rec8	225bpm	draw
	0x46,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x42,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,
	0x42,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x46,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,

	//rec8	225bpm	win
	0x49,0xff,0xff,0xfe,0x45,0xff,0xff,0xfe,0x49,0xff,0xff,0xfe,0x45,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,
};

const uint16_t sound_patternoffset[]={
	0x00,0x18,0x40,
};

const uint32_t sound_period[]={//225bpm,225bpm,225bpm
	1042,1042,1042,
};

const uint16_t sound_waveoffset[]={//rec4,rec8,rec8
	0xC0,0x80,0x80,
};


const int8_t *wave[2];
const uint8_t *patternp[2];
union REG32 chcounter[2];
uint16_t chop[2],patternc[2];
uint8_t note[2],oct[2];
volatile uint8_t play[2];

INLINE void sound_init(){
//timer settings
	TMR32B1MR0=1535;			//set period 1536(31250Hz)
	TMR32B1MR1=chbias;			//ch1 default data
	TMR32B1MR2=chbias;			//ch2 default data
	TMR32B1MR3=chbias;			//ch3 default data
	TMR32B1MCR=0x03;			//set interrupt and reset on match #0
	TMR32B1PWMC=0x0E;			//enable PWM on ch1~3
	TMR32B1TCR=0x01;			//start counter

//init variables
	chop[0]=chbias;
	chop[1]=chbias;
	note[0]=0x0F;
	note[1]=0x0F;
	play[0]=0;
	play[1]=0;
}

INLINE void sound_play(uint8_t ch,uint8_t sound){
	play[ch]=0;
	chop[ch]=chbias;
	note[ch]=0x0F;
	chcounter[ch].D=0;
	patternc[ch]=0;
	patternp[ch]=sound_pattern+sound_patternoffset[sound];
	wave[ch]=wavedata+sound_waveoffset[sound];
	play[ch]=1;
}

void TIMER32_1_IRQHandler(){
	register int ch,cdata,temp;

	TMR32B1MR1=chop[0];
	TMR32B1MR3=chop[1];
	TMR32B1IR=TMR32B1IR;		//acknowledgement

//read pattern
	for (ch=0;ch<2;++ch){
		if (play[ch]){
			if (!patternc[ch]){
				patternc[ch]=sound_period[ch];
				cdata=*(patternp[ch]++);
				temp=cdata&0x0F;
				if (temp!=0x0F){
					note[ch]=temp;
					oct[ch]=cdata>>4;
					if (temp==0x0D){	//stop
						play[ch]=0;
						note[ch]=0x0F;
						chop[ch]=chbias;
					}
				}
			}else{
				--patternc[ch];
			}
		}
	}

//update wave
	for (ch=0;ch<2;++ch){
		if (note[ch]<0x0C){
			chcounter[ch].D+=freqmul[note[ch]]<<oct[ch];
			chop[ch]=chbias+wave[ch][chcounter[ch].B3]*vol;
		}
	}
}
